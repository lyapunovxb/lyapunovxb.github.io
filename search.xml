<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gerrit仓库代码提交流程</title>
    <url>/2025/11/04/Git/gerrit%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[
生成个人密钥

ssh-keygen -C &lt;font style=&quot;color:rgb(33, 33, 33);&quot;&gt;wangxiangbo_JTAGI@cmss.chinamobile.com&lt;/font&gt;

修改config文件，增加gerrit仓库配置，增加刚生成的个人密钥&lt;font style=&quot;color:rgb(33, 33, 33);&quot;&gt;id_ed25519&lt;/font&gt;

host gerritport 29418hostname gerrit.cmss.comuser wangxiangbo_JTAGIIdentityFile ~/.ssh/id_ed25519


在gerrit中setting设置中，增加ssh的公钥，即&lt;font style=&quot;color:rgb(33, 33, 33);&quot;&gt;id_ed25519.pub&lt;/font&gt;

设置邮箱，邮箱名&lt;font style=&quot;color:rgb(33, 33, 33);&quot;&gt;wangxiangbo@cmss.chinamobile.com&lt;/font&gt;为不带JTAGI后缀的邮箱。

用ssh clone代码仓库


git clone &quot;ssh://wangxiangbo_JTAGI@gerrit.cmss.com:29418/AGI/CM_OPTIMUS&quot; &amp;&amp; scp -p -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg &quot;CM_OPTIMUS/.git/hooks/&quot;

查看分支

git branch -a


查看远端分支

git branch -r


通过远端origin&#x2F;develop仓库，创建一个本地develop开发分支

git checkout -b develop origin/develop


修改代码后，add之后并commit提交

git commit -v


推送远端origin&#x2F;develop仓库

git push origin HEAD:refs/for/develop


在推送过程中会出现缺失 Change-Id 的错误

gitdir=$(git rev-parse --git-dir); scp -p -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg $&#123;gitdir&#125;/hooks/

执行完毕后如果出现subsystem request failed on channel 0，则将-p修改为-O
gitdir=$(git rev-parse --git-dir); scp -O -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg $&#123;gitdir&#125;/hooks/

将本次commit提交的末尾加上Change-Id 
git commit --amend --no-edit

再次push
git push origin HEAD:refs/for/develop


提交完成之后，打开gerrit，找到develop分支的gitweb

选择review

找到刚刚提交的代码

点击add reviewer，评审人要最少要两个以上

第一次之后提交代码步骤


git pull origingit add xxxgit commit -v git push origin HEAD:refs/for/develop

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2025/11/04/Git/git%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[git commmit -v和git push origin develop之后，我怎么撤销本次commit提交的代码，将origin develop的仓库返回值提交之前的状态？
在Git中，如果你想要撤销最近的一次提交并将仓库状态回退到提交之前，你可以使用git reset命令。这里有几种方法可以撤销提交：

使用git reset --soft：
这个命令会将HEAD指针移动到指定的提交，但是不会改变工作目录和索引的状态。这意味着你的更改仍然在暂存区（staged），你可以重新提交。
命令：git reset --soft HEAD~1（将HEAD指针回退到上一个提交）


使用git reset --mixed（默认选项）：
这个命令会将HEAD指针移动到指定的提交，并且将索引（staged changes）重置到HEAD的状态，但是不会改变工作目录。
命令：git reset --mixed HEAD~1（将HEAD和索引回退到上一个提交，但工作目录不变）


使用git reset --hard：
这个命令会将HEAD指针、索引和工作目录都重置到指定的提交状态。这意味着所有未提交的更改都会丢失。
命令：git reset --hard HEAD~1（将HEAD、索引和工作目录都回退到上一个提交）



如果你已经将代码推送到了远程仓库（比如origin develop），并且想要撤销这次推送，你可以使用git push命令配合--force选项来强制推送本地的更改到远程仓库。但是请注意，这会覆盖远程仓库的历史，所以只有在你确定远程仓库没有其他人的提交或者你不介意丢失这些提交时才应该使用。
命令如下：
git push origin develop --force

或者，如果你使用的是Git 2.0或更高版本，可以使用更安全的--force-with-lease选项，它会在远程分支没有新的提交时才允许强制推送。
命令如下：
git push origin develop --force-with-lease

警告：使用--force选项会覆盖远程仓库的历史，这是一个破坏性的操作。在团队协作的环境中，这可能会导致其他协作者的工作丢失，所以请谨慎使用。
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式训练参数关系</title>
    <url>/2025/11/04/LLM/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E5%8F%82%E6%95%B0%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[:::color4npu 总卡数&#x3D;NNODES*NPUS_PER_NODE
:::
:::color1npu 总卡数&#x3D;dptppp
:::
:::color2gbs&#x3D;mbsnpu 总卡数&#x3D;mbsdptppp
:::
为什么有的配置文件没有满足gbs&#x3D;mbs*npu 总卡数，gbs设置的会大很多，但是也能拉起训练，这是为什么呢？例如npu 总卡数为16，mbs为1，但是gbs设置的是32、64、128这些？
GBS&#x3D;MBS×DP×TP×PP
其中：

DP 是数据并行的设备数。
TP 是张量并行的设备数。
PP 是流水线并行的设备数。
总设备数 是 DP × TP × PP。

在你的例子中，NPU 总卡数为 16，MBS &#x3D; 1，但 GBS 被设置为 32、64、128 等，这看起来似乎不满足上述关系。然而，这种情况仍然可以正常启动训练，原因可能如下：
1. 梯度累积（Gradient Accumulation）
即使 GBS &gt; MBS × 总设备数，也可以通过 梯度累积 来实现。梯度累积是一种技术，允许模型在多个小批次（micro-batches）上累积梯度，然后一次性更新模型参数。具体来说：
假设 GBS &#x3D; 64，MBS &#x3D; 1，总设备数为 16。
每个设备每次处理 1 个样本，但模型会累积 64 个样本的梯度后才进行一次参数更新。
这相当于逻辑上处理了一个大小为 64 的批次，但物理上每次只处理 1 个样本。
这种方法可以有效利用有限的设备内存，同时保持较大的全局批次大小，从而提高训练的稳定性和收敛速度。
2. 框架的优化和灵活性
一些深度学习框架（如 PyTorch、DeepSpeed 等）在内部实现了对 GBS &gt; MBS × 总设备数 的支持。这些框架通过以下方式实现：
自动梯度累积：框架会自动管理梯度累积过程，用户无需手动干预。
优化的通信机制：框架会优化设备之间的通信，确保在累积梯度时不会引入过多的通信开销。
3. 示例解释
假设你有 16 个设备（NPU），MBS &#x3D; 1，GBS &#x3D; 64：
每个设备每次处理 1 个样本。
模型需要累积 64 个样本的梯度后才进行一次更新。
这意味着每个设备需要累积 4 次（因为 64&#x2F;16&#x3D;4），才能完成一次全局批次的梯度更新。
这种配置在实际训练中是可行的，因为它通过梯度累积实现了较大的全局批次大小，同时避免了单次处理大量数据带来的内存压力。
4. 为什么这样做的好处
内存优化：较小的 MBS 可以显著减少单个设备的内存占用，使得模型能够在有限的硬件资源上运行。
训练稳定性：较大的 GBS 可以提高训练的稳定性和收敛速度，尤其是在处理大规模数据集时。
灵活性：通过梯度累积，用户可以在不增加硬件资源的情况下，灵活调整全局批次大小。
总结
即使 GBS &gt; MBS × 总设备数，仍然可以通过 梯度累积 来实现训练。这种做法在实际应用中非常常见，尤其是在资源受限的情况下。通过这种方式，可以在保持较小 MBS 的同时，利用较大的 GBS 提高训练效果。
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>分布式训练</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab仓库代码提交流程</title>
    <url>/2025/11/04/Git/gitlab%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[
gitlab上fork主仓库，生成个人的远端仓库origin&#x2F;develop
修改git提交用户配置为九天账号

git config --global --listgit config --global user.name wangxiangbo_JTAGIgit config --global user.email wangxiangbo_JTAGI@cmss.chinamobile.com


拉取个人的远端仓库

git clone http://gitlab.cmss.com/wangxiangbo/CM_OPTIMUS.git 


查看分支

git branch -a


查看远程仓库分支

git branch -r


通过个人的远端origin&#x2F;develop仓库，创建一个本地develop开发分支

git checkout -b develop origin/develop


列出所有的远程仓库以及对应的 URL

git remote -v



将远程仓库地址添加到本地Git仓库的远程仓库列表中，本地的upstream&#x2F;develop仓库会和gitlab远程仓库关联起来

git remote add upstream http://gitlab.cmss.com/AGI/CM_OPTIMUS.git



upstream&#x2F;develop远端仓库拉取最新的代码

git fetch upstream



将upstream&#x2F;develop远端仓库的最新代码合并到本地的develop分支中

git merge upstream/develop



将本地develop最新的代码推到个人的远端仓库origin&#x2F;develop中

git push origin develop


提交develop到origin&#x2F;develop代码之前，保证自己的本地个人的远端仓库origin&#x2F;develop和本地gitlab的远端仓库upstream&#x2F;develop保持一致再提交，防止后续origin&#x2F;develop合并打upstream&#x2F;develop上出现冲突。

#本地代码修改后拉取最新代码#1.拉取源代码git fetch upstream #2.暂存本地修改的代码git stash#3.合并源代码到当前的develop仓库git merge upstream/develop#4.将本地修改的推送到远程的origin分支，使origin/develop和upstream/develop保持一致git push origin develop#5.将暂存的代码弹出来git stash pop


souretree上add需要提交的代码
提交add之后的代码

git commit -v


#修改下方的提交信息，第一行为提交描述信息deepseek-7B预训练Code Source From: Self CodeDescription: deepseek-7B预训练Jira: #CMOPTIMUS-1089市场项目编号（名称）：CM_OPTIMUS


将提交完之后的代码合并到origin&#x2F;develop上

git push origin develop


gitlab中找的到自己仓库下CM_OPTIMUS
找到Merge requests，然后点击开始一个合并
然后选择自己的分支为develop，还有旁边的分支develop，然后点击最下方的merge即可。该操作是将自己个人远端的orgin&#x2F;develop仓库提交修改后的代码合并到gitlab远端的主仓库中（upstream&#x2F;develop已和其关联，并通过git fetch保持最新）

选中自己刚刚提交到origin&#x2F;develop上的代码，合并到AGI&#x2F;CM_OPTIMUS的develop分支上
在Write里添加合并人信息
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2025/11/04/Linux/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[
当执行训练任务时，手动关闭训练，此时gup资源仍然占用，需要手动kill掉进程

查询正在运行的进程并gerp finetune_lora_single_gpu.sh
ps aux | grep finetune_lora_single_gpu.sh
ps aux | grep finetune_lora_ds.sh
kill -9 372813 根据上一步查出来的进程号，用kill -9强制删除
nvidia-smi 查看是否gpu显存已经清空

查看某个文件的前20行

head -n 20 train_data_law.json

查看当前文件夹的大小

du -sh .

查看当前文件夹挂载的是哪一个盘

df -h .
从大到小查看当前文件夹的下的文件大小
du -sh * | sort -rh

查看当前文件下所有文件的大小

ls -lh

把一个名为Yuan2的文件夹的所有内容（包括该文件夹名），cp到&#x2F;mnt&#x2F;users&#x2F;wangxiangbo&#x2F;nemo&#x2F;model目录下，使最后的目录为 &#x2F;mnt&#x2F;users&#x2F;wangxiangbo&#x2F;nemo&#x2F;model&#x2F;Yuan2

cp -a Yuan2 /mnt/users/wangxiangbo/nemo/model/

通过pid查看某个进程的详细信息

&lt;font style=&quot;color:rgb(56, 58, 66);background-color:rgb(250, 250, 250);&quot;&gt;ps -fp 167891&lt;/font&gt;

查看当前目录下所有文件的磁盘占用情况

du -ah | sort -hr | head -n 20

使用以下命令将megatron-core文件夹压缩成一个名为megatron-core.zip的zip文件
 zip -r megatron-core.zip megatron-core 

使用以下命令将megatron-core.zip解压缩


unzip megatron-core.zip 

hg上面下载模型

pip install -U huggingface_hubhuggingface-cli download bigscience/bloom-560m --local-dir bloom-560mhuggingface-cli download Qwen/Qwen2-7B-Instruct --local-dir Qwen2-7B-Instructhuggingface-cli download Qwen/Qwen2.5-7B-Instruct --local-dir Qwen2.5-7B-Instructhuggingface-cli download BAAI/IndustryCorpus_computer --repo-type dataset --local-dir IndustryCorpus_computerhuggingface-cli download BAAI/IndustryCorpus2_current_affairs_government_administration --repo-type dataset --local-dir government_administrationhuggingface-cli download ShengbinYue/DISC-Law-SFT --repo-type dataset --local-dir DISC-Law-SFThuggingface-cli download TigerResearch/sft_zh


归档压缩文件

#-c：创建一个新的压缩文件。#-z：通过 gzip 压缩文件。#-v：显示详细的压缩过程。#-f：指定压缩后的文件名，这里是 colossalai.tar.gztar -czvf colossalai.tar.gz colossalai/  #-x：表示解压。#-z：表示解压 .gz 格式的文件。#-v：显示解压过程。#-f：指定解压的文件tar -xzvf file.tar.gz



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kimi问题</title>
    <url>/2025/11/04/Linux/kimi%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[
权重转换代码换行符

Kimi: 出现这些错误通常是因为脚本文件在不同的操作系统环境下被编辑或创建，导致文件的换行符不一致。Unix&#x2F;Linux系统使用LF（Line Feed，\n）作为换行符，而Windows系统使用CR+LF（Carriage Return + Line Feed，\r\n）作为换行符。
错误信息中的 $&#39;\r&#39;: command not found 表示脚本尝试执行一个以 \r 开头的命令，这通常是因为脚本文件中的换行符是 \r\n 而不是 \n。
此外，syntax error near unexpected token &#39;elif&#39; 错误表明脚本解析器在遇到 elif 时遇到了语法错误，这可能是因为 elif 之前的行（可能是第59行）以 \r\n 结尾，导致 elif 行实际上是从一个新的行开始，而不是在预期的位置。
要解决这个问题，你可以使用 dos2unix 工具将脚本文件从Windows格式转换为Unix&#x2F;Linux格式。如果你没有 dos2unix 工具，可以使用 sed 命令来移除 \r 字符：
sed -i &#x27;s/\r$//&#x27; hf2mcore_convertor.sh

这条命令会查找文件中的所有行，并移除每行末尾的 \r 字符。
如果你有 dos2unix 工具，可以使用以下命令：
dos2unix hf2mcore_convertor.sh

这将把文件从Windows格式转换为Unix&#x2F;Linux格式。
在运行这些命令之后，再次执行脚本应该就不会出现这些错误了。

修改文件遇到Read-only file system

Kimi: 当你遇到 “Read-only file system” 错误时，通常意味着你的文件系统出于某种原因被挂载为只读模式。这可能是由于文件系统损坏、磁盘硬件问题、或者挂载时指定了错误的参数。以下是一些解决步骤：

检查文件系统挂载状态：使用 mount 命令查看所有挂载的文件系统及其状态。你可以使用如下命令：

mount | grep /path/to/mount/point

查看挂载点是否为只读（ro）。

重新挂载文件系统为读写模式：如果文件系统被挂载为只读，你可以尝试重新挂载它为读写模式。使用以下命令：

sudo mount -o remount,rw /path/to/mount/point

请将 /path/to/mount/point 替换为实际的挂载点路径。

检查和修复文件系统：如果重新挂载不起作用，可能是文件系统损坏。你可以使用 fsck 命令来检查和修复文件系统。例如，对于 ext4 文件系统，可以使用：

sudo fsck -f /dev/sda1

请确保替换 /dev/sda1 为你的实际分区。
]]></content>
      <categories>
        <category>Liunx</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令</title>
    <url>/2025/11/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[
sudo docker run -it --name qwen --gpus all nvidia/cuda:12.2.2-cudnn8-devel-ubuntu22.04启动一个容器后，又通过exit关闭。发现docker ps没有了，该如何重新启动这个qwen容器？

&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;docker ps -a&lt;/font&gt;
&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;docker start qwen&lt;/font&gt;
&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;docker exec -it 容器id bash&lt;/font&gt;

拉取一个新镜像后，通过这个镜像创建一个容器。

&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;docker run -it --name qwen --gpus all 镜像名:镜像tags bash&lt;/font&gt;

将此时qwen容器打成镜像

docker commit -a &quot;wangxiangbo&quot; -m &quot;qwen 7B&quot; 02649afd9710 qwen-7b:v1.0
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s命令</title>
    <url>/2025/11/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/k8s%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[
获取特定命名空间的详细信息

&lt;font style=&quot;color:rgb(56, 58, 66);&quot;&gt;kubectl get ns &lt;/font&gt;&lt;font style=&quot;color:rgb(64, 120, 242);&quot;&gt;&lt;&lt;/font&gt;&lt;font style=&quot;color:rgb(56, 58, 66);&quot;&gt;namespace-name&lt;/font&gt;&lt;font style=&quot;color:rgb(64, 120, 242);&quot;&gt;&gt;&lt;/font&gt;&lt;font style=&quot;color:rgb(56, 58, 66);&quot;&gt; -o wide&lt;/font&gt;

kubectl通过ns获取所有的pods的详细信息

kubectl get pods -n &lt;ns_name&gt; -o wide

删除启动失败的pod，可以直接删除启动时的yaml，否则pod会自动重启

kubectl delete -f qwentest.yaml

查看所有的node的lable标签信息

kubectl get node --show-labels
kubectl get node xxx --show-labels
kubectl get node --show-labels | grep model

打标签

kubectl label nodes ecs-jhjs-1234-003 key=vaule

删除某节点的lable标签

kubectl label nodes cce100-64-29-79.cce-stack.com model-

创建一个命名空间namespace

kubectl create namespace xxx

查看所有节点的标签

kubectl get nodes --show-labels
kubectl get nodes --show-labels | grep model=llama2-70b
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>测试 Hexo 标签分类2</title>
    <url>/2025/10/31/%E9%A1%B5%E9%9D%A2%E6%B5%8B%E8%AF%95/test%20copy/</url>
    <content><![CDATA[这是文章正文。
]]></content>
      <categories>
        <category>日志1 - 分类测试2 - 分类测试3</category>
      </categories>
      <tags>
        <tag>测试2</tag>
        <tag>hexo2</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode免密</title>
    <url>/2025/11/04/Linux/vscode%E5%85%8D%E5%AF%86/</url>
    <content><![CDATA[ssh-keygen -t rsa -b 4096私钥文件: id_rsa公钥文件:id_rsa.pub
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
