[{"title":"前端1_调用api接口的写法","url":"/2025/11/06/前端/前端1_调用api接口的写法/","content":"\n### Get请求写法\n#### 1. 看Parameters中是否有需要带参数，其中`Authorization`为授权认证的token可以不用考虑。\n1.1 若是没有其余的参数限定，那么SyncRequestFuncType<请求参数类型,响应返回参数类型>，第一个参数就为void或者undefined。返回类型可以使用any，等获取到响应参数之后，在对其通过Interface/type进行明确。\n\n```javascript\nexport const getApi: SyncRequestFuncType<\nvoid,\nresponseType\n> = () => {\nreturn javaAxios({\n method: \"get\",\n url: \"xxx/xxxx\",\n});\n};\n```\n\n1.2 若是有其余参数限定，这时需要箭头函数中需要带着params来进行请求，且reuturn中也需要将params带着。\n\n\t1.2.1 `单个参数`，例如id，这时在请求参数类型中，需要明确出请求参数的类型<{id:string},responseType>，这时请求参数的类型为对象{}的形式，可以直接在尖括号中写出来，也可以通过引入定义的Interface/type类型来写<IdType,responseType>。\n\n```javascript\nexport const getApi: SyncRequestFuncType<\n {id:string},\n void\n> = (params) => {\nreturn javaAxios({\n method: \"get\",\n url: \"xxx/xxxx\",\n params,\n});\n};\n```\n\n\t1.2.2 `多个参数`，例如email，type...，因为参数比较多，最好通过Interface/type的方式SendEmailCaptchaForUserInfoModifyType来明确请求参数类型。\n\n```javascript\nexport type SendEmailCaptchaForUserInfoModifyType = {\ntype: ModifyType;\nemail?: string;\n};\n```\n\n```javascript\nexport const getApi: SyncRequestFuncType<\nSendEmailCaptchaForUserInfoModifyType,\nvoid\n> = (params) => {\nreturn javaAxios({\n method: \"get\",\n url: \"xxx/xxx\",\n params,\n});\n};\n```\n\n### Post请求写法\n#### 1. 看看Parameters中是否有需要带参数，其中`Authorization`为授权认证的token可以不用考虑。\n1.1 若是没有其余的参数限定，那么SyncRequestFuncType<请求参数类型,响应返回参数类型>，第一个参数就为void或者undefined。返回类型可以使用any，等获取到响应参数之后，在对其通过Interface/type进行明确。\n\n```javascript\nexport const clearVideoRecycle: SyncRequestFuncType<void, void> = () => {\nreturn javaAxios({\n method: \"post\",\n url: \"xxx/xxx\",\n});\n};\n```\n\n1.2 若是有其余参数限定，这时需要箭头函数中需要带着params来进行请求，且reuturn中也需要将params带着。\n\n\t1.2.1 单个参数时\n\n```javascript\nexport const cancelSubscribeVideo: SyncRequestFuncType<\n{ themeId: string },\nany\n> = (params) => {\nreturn javaAxios({\n method: \"post\",\n url: \"xxx/xxx\",\n params,\n});\n};\n```\n\n\t1.2.2 多个参数时\n\n```javascript\nexport type SendEmailCaptchaForUserInfoModifyType = {\ntype: ModifyType;\nemail?: string;\n};\n```\n\n```javascript\nexport const sendEmailCaptchaForUserInfoModify: SyncRequestFuncType<\nSendEmailCaptchaForUserInfoModifyType,\nvoid\n> = (params) => {\nreturn javaAxios({\n method: \"get\",\n url: \"xxx/xxx\",\n params,\n});\n};\n```\n\n#### 2. 当出现请求体`Request body`时，这时就需要在return的javaAxios中添加键值对`data: params`，来将参数添加到请求体中传递过去。\n2.1 Request body为：\n\n```javascript\n[\n\"string\"\n]\n```\n\n```javascript\nexport const batchDeleteVideo: SyncRequestFuncType<string[], void> = (\nparams\n) => {\nreturn javaAxios({\n method: \"post\",\n url: \"videos/themes/batchDel\",\n data: params,\n});\n};\n```\n\n2.2 Request body为：这时候需要在data中进一步在约束一下，使其对应api的请求体的格式。\n\n```javascript\n{\n\"themes\": [\n \"string\"\n]\n}\n```\n\n```javascript\nexport const sortVideos: SyncRequestFuncType<string[], void> = (params) => {\nreturn javaAxios({\n method: \"post\",\n url: \"videos/themes/changeVideoThemesSort\",\n data: { themes: params },\n});\n};\n```\n\n","tags":["前端","Javascript"],"categories":["前端"]},{"title":"Git2_gerrit仓库代码提交流程","url":"/2025/11/04/Git/Git2_gerrit仓库代码提交流程/","content":"1. 生成个人密钥\n```bash\nssh-keygen -C wangxiangbo_JTAGI@cmss.chinamobile.com\n```\n2. 修改config文件，增加gerrit仓库配置，增加刚生成的个人密钥`id_ed25519`\n```bash\nhost gerrit\nport 29418\nhostname gerrit.cmss.com\nuser wangxiangbo_JTAGI\nIdentityFile ~/.ssh/id_ed25519\n```\n3. 在gerrit中setting设置中，增加ssh的公钥，即`id_ed25519.pub`\n4. 设置邮箱，邮箱名`wangxiangbo@cmss.chinamobile.com`为不带JTAGI后缀的邮箱。\n5. 用ssh clone代码仓库\n```bash\ngit clone \"ssh://wangxiangbo_JTAGI@gerrit.cmss.com:29418/AGI/CM_OPTIMUS\" && scp -p -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg \"CM_OPTIMUS/.git/hooks/\"\n```\n6. 查看分支\n```bash\ngit branch -a\n```\n7. 查看远端分支\n```bash\ngit branch -r\n```\n8. 通过远端origin/develop仓库，创建一个本地develop开发分支\n```bash\ngit checkout -b develop origin/develop\n```\n9. 修改代码后，add之后并commit提交\n```bash\ngit commit -v\n```\n10. 推送远端origin/develop仓库\n```bash\ngit push origin HEAD:refs/for/develop\n```\n11. 在推送过程中会出现缺失 `Change-Id `的错误\n```bash\ngitdir=$(git rev-parse --git-dir); scp -p -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg ${gitdir}/hooks/\n```\n执行完毕后如果出现subsystem request failed on channel 0，则将-p修改为-O\n```bash\ngitdir=$(git rev-parse --git-dir); scp -O -P 29418 wangxiangbo_JTAGI@gerrit.cmss.com:hooks/commit-msg ${gitdir}/hooks/\n```\n将本次commit提交的末尾加上Change-Id \n```bash\ngit commit --amend --no-edit\n```\n再次push\n```bash\ngit push origin HEAD:refs/for/develop\n```\n12. 提交完成之后，打开gerrit，找到develop分支的gitweb\n13. 选择review\n14. 找到刚刚提交的代码\n15. 点击add reviewer，评审人要最少要两个以上\n16. 第一次之后提交代码步骤\n```bash\ngit pull origin\ngit add xxx\ngit commit -v \ngit push origin HEAD:refs/for/develop\n```\n\n","tags":["开发","gerrit"],"categories":["开发"]},{"title":"Git3_gitlab仓库代码提交流程","url":"/2025/11/04/Git/Git3_gitlab仓库代码提交流程/","content":"1. gitlab上fork主仓库，生成个人的远端仓库origin/develop\n2. 修改git提交用户配置为九天账号\n```bash\ngit config --global --list\ngit config --global user.name wangxiangbo_JTAGI\ngit config --global user.email wangxiangbo_JTAGI@cmss.chinamobile.com\n```\n3. 拉取个人的远端仓库\n```bash\ngit clone http://gitlab.cmss.com/wangxiangbo/CM_OPTIMUS.git \n```\n4. 查看分支\n```bash\ngit branch -a\n```\n5. 查看远程仓库分支\n```bash\ngit branch -r\n```\n6. 通过个人的远端origin/develop仓库，创建一个本地develop开发分支\n```bash\ngit checkout -b develop origin/develop\n```\n7. <font style=\"color:rgba(0, 0, 0, 0.85);\">列出所有的远程仓库以及对应的 URL</font>\n```bash\ngit remote -v\n```\n8. <font style=\"color:rgba(0, 0, 0, 0.85);\">将远程仓库地址添加到本地Git仓库的远程仓库列表中，本地的upstream/develop仓库会和gitlab远程仓库关联起来</font>\n```bash\ngit remote add upstream http://gitlab.cmss.com/AGI/CM_OPTIMUS.git\n```\n8. upstream/develop远端仓库拉取最新的代码\n```bash\ngit fetch upstream\n```\n9. 将upstream/develop远端仓库的最新代码合并到本地的develop分支中\n```bash\ngit merge upstream/develop\n```\n10. 将本地develop最新的代码推到个人的远端仓库origin/develop中\n```bash\ngit push origin develop\n```\n11. <font style=\"background-color:#FBDE28;\">提交develop到origin/develop代码之前，保证自己的本地个人的远端仓库origin/develop和本地gitlab的远端仓库upstream/develop保持一致再提交</font>，防止后续origin/develop合并打upstream/develop上出现冲突。\n```bash\n#本地代码修改后拉取最新代码\n#1.拉取源代码\ngit fetch upstream \n#2.暂存本地修改的代码\ngit stash\n#3.合并源代码到当前的develop仓库\ngit merge upstream/develop\n#4.将本地修改的推送到远程的origin分支，使origin/develop和upstream/develop保持一致\ngit push origin develop\n#5.将暂存的代码弹出来\ngit stash pop\n```\n12. souretree上add需要提交的代码\n13. 提交add之后的代码\n```bash\ngit commit -v\n```\n```bash\n#修改下方的提交信息，第一行为提交描述信息\ndeepseek-7B预训练\n\nCode Source From: Self Code\nDescription: deepseek-7B预训练\nJira: #CMOPTIMUS-1089\n市场项目编号（名称）：CM_OPTIMUS\n```\n14. <font style=\"color:rgb(55, 53, 47);\">将提交完之后的代码合并到origin/develop上</font>\n```bash\ngit push origin develop\n```\n15. <font style=\"color:rgb(55, 53, 47);\">gitlab中找的到自己仓库下CM_OPTIMUS</font>\n16. <font style=\"color:rgb(55, 53, 47);\">找到Merge requests，然后点击开始一个合并</font>\n17. <font style=\"color:rgb(55, 53, 47);\">然后选择自己的分支为develop，还有旁边的分支develop，然后点击最下方的merge即可。该操作是将自己个人远端的orgin/develop仓库提交修改后的代码合并到gitlab远端的主仓库中（upstream/develop已和其关联，并通过git fetch保持最新）</font>\n选中自己刚刚提交到origin/develop上的代码，合并到AGI/CM_OPTIMUS的develop分支上\n在Write里添加合并人信息\n\n\n\n","tags":["开发","gitlab"],"categories":["开发"]},{"title":"Git1_git命令","url":"/2025/11/04/Git/Git1_git 命令/","content":"**<font style=\"background-color:#FBDE28;\">git commmit -v和git push origin develop之后，我怎么撤销本次commit提交的代码，将origin develop的仓库返回值提交之前的状态？</font>**\n\n在Git中，如果你想要撤销最近的一次提交并将仓库状态回退到提交之前，你可以使用`git reset`命令。这里有几种方法可以撤销提交：\n\n1. **使用**`git reset --soft`：\n    - 这个命令会将HEAD指针移动到指定的提交，但是不会改变工作目录和索引的状态。这意味着你的更改仍然在暂存区（staged），你可以重新提交。\n    - 命令：`git reset --soft HEAD~1`（将HEAD指针回退到上一个提交）\n2. **使用**`git reset --mixed`（默认选项）：\n    - 这个命令会将HEAD指针移动到指定的提交，并且将索引（staged changes）重置到HEAD的状态，但是不会改变工作目录。\n    - 命令：`git reset --mixed HEAD~1`（将HEAD和索引回退到上一个提交，但工作目录不变）\n3. **使用**`git reset --hard`：\n    - 这个命令会将HEAD指针、索引和工作目录都重置到指定的提交状态。这意味着所有未提交的更改都会丢失。\n    - 命令：`git reset --hard HEAD~1`（将HEAD、索引和工作目录都回退到上一个提交）\n\n如果你已经将代码推送到了远程仓库（比如`origin develop`），并且想要撤销这次推送，你可以使用`git push`命令配合`--force`选项来强制推送本地的更改到远程仓库。但是请注意，这会覆盖远程仓库的历史，所以只有在你确定远程仓库没有其他人的提交或者你不介意丢失这些提交时才应该使用。\n\n命令如下：\n\n```bash\ngit push origin develop --force\n```\n\n或者，如果你使用的是Git 2.0或更高版本，可以使用更安全的`--force-with-lease`选项，它会在远程分支没有新的提交时才允许强制推送。\n\n命令如下：\n\n```bash\ngit push origin develop --force-with-lease\n```\n\n**警告**：使用`--force`选项会覆盖远程仓库的历史，这是一个破坏性的操作。在团队协作的环境中，这可能会导致其他协作者的工作丢失，所以请谨慎使用。\n\n","tags":["开发","git"],"categories":["开发"]},{"title":"Linux1_kimi问题","url":"/2025/11/04/Linux/Linux1_kimi问题/","content":"1. 权重转换代码换行符\nKimi: 出现这些错误通常是因为脚本文件在不同的操作系统环境下被编辑或创建，导致文件的换行符不一致。Unix/Linux系统使用LF（Line Feed，`\\n`）作为换行符，而Windows系统使用CR+LF（Carriage Return + Line Feed，`\\r\\n`）作为换行符。\n错误信息中的 `$'\\r': command not found` 表示脚本尝试执行一个以 `\\r` 开头的命令，这通常是因为脚本文件中的换行符是 `\\r\\n` 而不是 `\\n`。\n此外，`syntax error near unexpected token 'elif'` 错误表明脚本解析器在遇到 `elif` 时遇到了语法错误，这可能是因为 `elif` 之前的行（可能是第59行）以 `\\r\\n` 结尾，导致 `elif` 行实际上是从一个新的行开始，而不是在预期的位置。\n要解决这个问题，你可以使用 `dos2unix` 工具将脚本文件从Windows格式转换为Unix/Linux格式。如果你没有 `dos2unix` 工具，可以使用 `sed` 命令来移除 `\\r` 字符：\n```bash\nsed -i 's/\\r$//' hf2mcore_convertor.sh\n```\n这条命令会查找文件中的所有行，并移除每行末尾的 `\\r` 字符。\n如果你有 `dos2unix` 工具，可以使用以下命令：\n```bash\ndos2unix hf2mcore_convertor.sh\n```\n这将把文件从Windows格式转换为Unix/Linux格式。\n在运行这些命令之后，再次执行脚本应该就不会出现这些错误了。\n2. 修改文件遇到Read-only file system\nKimi: 当你遇到 \"Read-only file system\" 错误时，通常意味着你的文件系统出于某种原因被挂载为只读模式。这可能是由于文件系统损坏、磁盘硬件问题、或者挂载时指定了错误的参数。以下是一些解决步骤：\n1. **检查文件系统挂载状态**：  \n使用 `mount` 命令查看所有挂载的文件系统及其状态。你可以使用如下命令：\n```bash\nmount | grep /path/to/mount/point\n```\n查看挂载点是否为只读（ro）。\n2. **重新挂载文件系统为读写模式**：  \n如果文件系统被挂载为只读，你可以尝试重新挂载它为读写模式。使用以下命令：\n```bash\nsudo mount -o remount,rw /path/to/mount/point\n```\n请将 `/path/to/mount/point` 替换为实际的挂载点路径。\n3. **检查和修复文件系统**：  \n如果重新挂载不起作用，可能是文件系统损坏。你可以使用 `fsck` 命令来检查和修复文件系统。例如，对于 ext4 文件系统，可以使用：\n```bash\nsudo fsck -f /dev/sda1\n```\n请确保替换 `/dev/sda1` 为你的实际分区。\n\n","tags":["运维","Linux"],"categories":["Liunx"]},{"title":"Linux2_Linux命令","url":"/2025/11/04/Linux/Linux2_linux命令/","content":"1. 当执行训练任务时，手动关闭训练，此时gup资源仍然占用，需要手动kill掉进程\n查询正在运行的进程并gerp finetune_lora_single_gpu.sh\n`ps aux | grep finetune_lora_single_gpu.sh`\n`ps aux | grep finetune_lora_ds.sh`\n`kill -9 372813` 根据上一步查出来的进程号，用kill -9强制删除\n`nvidia-smi `查看是否gpu显存已经清空\n2. 查看某个文件的前20行\n`head -n 20 train_data_law.json`\n3. 查看当前文件夹的大小\n`du -sh .`\n4. 查看当前文件夹挂载的是哪一个盘\n`df -h .`\n从大到小查看当前文件夹的下的文件大小\n`du -sh * | sort -rh`\n4. 查看当前文件下所有文件的大小\n`ls -lh`\n5. <font style=\"color:#000000;\">把一个名为Yuan2的文件夹的所有内容（包括该文件夹名），cp到/mnt/users/wangxiangbo/nemo/model目录下，使最后的目录为 /mnt/users/wangxiangbo/nemo/model/Yuan2</font>\n`cp -a Yuan2 /mnt/users/wangxiangbo/nemo/model/`\n6. 通过pid查看某个进程的详细信息\n`<font style=\"color:rgb(56, 58, 66);background-color:rgb(250, 250, 250);\">ps -fp 167891</font>`\n7. 查看当前目录下所有文件的磁盘占用情况\n`du -ah | sort -hr | head -n 20`\n8.  使用以下命令将`megatron-core`文件夹压缩成一个名为`megatron-core.zip`的zip文件\n \t` zip -r megatron-core.zip megatron-core  `\n9.  使用以下命令将`megatron-core.zip`解压缩  \n` unzip megatron-core.zip  `\n11. hg上面下载模型\n```bash\npip install -U huggingface_hub\nhuggingface-cli download bigscience/bloom-560m --local-dir bloom-560m\nhuggingface-cli download Qwen/Qwen2-7B-Instruct --local-dir Qwen2-7B-Instruct\nhuggingface-cli download Qwen/Qwen2.5-7B-Instruct --local-dir Qwen2.5-7B-Instruct\nhuggingface-cli download BAAI/IndustryCorpus_computer --repo-type dataset --local-dir IndustryCorpus_computer\nhuggingface-cli download BAAI/IndustryCorpus2_current_affairs_government_administration --repo-type dataset --local-dir government_administration\nhuggingface-cli download ShengbinYue/DISC-Law-SFT --repo-type dataset --local-dir DISC-Law-SFT\nhuggingface-cli download TigerResearch/sft_zh\n```\n12. 归档压缩文件\n```bash\n#-c：创建一个新的压缩文件。\n#-z：通过 gzip 压缩文件。\n#-v：显示详细的压缩过程。\n#-f：指定压缩后的文件名，这里是 colossalai.tar.gz\ntar -czvf colossalai.tar.gz colossalai/  \n\n#-x：表示解压。\n#-z：表示解压 .gz 格式的文件。\n#-v：显示解压过程。\n#-f：指定解压的文件\ntar -xzvf file.tar.gz\n```\n\n\n\n","tags":["运维","Linux"],"categories":["Linux"]},{"title":"k8s命令","url":"/2025/11/04/服务器运维/k8s命令/","content":"1. <font style=\"color:rgb(6, 6, 7);\">获取特定命名空间的详细信息</font>\n\n`<font style=\"color:rgb(56, 58, 66);\">kubectl get ns </font><font style=\"color:rgb(64, 120, 242);\"><</font><font style=\"color:rgb(56, 58, 66);\">namespace-name</font><font style=\"color:rgb(64, 120, 242);\">></font><font style=\"color:rgb(56, 58, 66);\"> -o wide</font>`\n\n2. kubectl通过ns获取所有的pods的详细信息\n\n`kubectl get pods -n <ns_name> -o wide`\n\n3. 删除启动失败的pod，可以直接删除启动时的yaml，否则pod会自动重启\n\n`kubectl delete -f qwentest.yaml`\n\n4. 查看所有的node的lable标签信息\n\n`kubectl get node --show-labels`\n\n`kubectl get node xxx --show-labels`\n\n`kubectl get node --show-labels | grep model`\n\n5. 打标签\n\n`kubectl label nodes ecs-jhjs-1234-003 key=vaule`\n\n6. 删除某节点的lable标签\n\n`kubectl label nodes cce100-64-29-79.cce-stack.com model-`\n\n6. 创建一个命名空间namespace\n\n`kubectl create namespace xxx`\n\n7. 查看所有节点的标签\n\n`kubectl get nodes --show-labels`\n\n`kubectl get nodes --show-labels | grep model=llama2-70b`\n\n","tags":["运维","k8s"],"categories":["运维"]},{"title":"docker命令","url":"/2025/11/04/服务器运维/docker命令/","content":"1. 启动一个容器\n```bash\nsudo docker run -it --name qwen --gpus all nvidia/cuda:12.2.2-cudnn8-devel-ubuntu22.04\n```\n启动一个容器后，又通过exit关闭。发现docker ps没有了，该如何重新启动这个qwen容器？\n```bash\ndocker ps -a\n\ndocker start qwen\n\ndocker exec -it 容器id bash\n```\n\n2. 拉取一个新镜像后，通过这个镜像创建一个容器。\n```bash\ndocker run -it --name qwen --gpus all 镜像名:镜像tags bash\n```\n\n3. 将此时qwen容器打成镜像\n```bash\ndocker commit -a \"wangxiangbo\" -m \"qwen 7B\" 02649afd9710 qwen-7b:v1.0\n```\n\n\n\n\n","tags":["运维","docker"],"categories":["运维"]},{"title":"测试 Hexo 标签分类2","url":"/2025/10/31/页面测试/test copy/","content":"这是文章正文。","tags":["测试2","hexo2"],"categories":["日志1 - 分类测试2 - 分类测试3"]}]